/*++ 
 * linux/drivers/media/video/wmt_v4l2/cmos/cmos-dev-hy.c
 * WonderMedia v4l cmos device driver
*
 * Copyright c 2010  WonderMedia  Technologies, Inc.
 *
 * This program is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, either version 2 of the License, or 
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details. 
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
 * WonderMedia Technologies, Inc.
 * 4F, 533, Chung-Cheng Road, Hsin-Tien, Taipei 231, R.O.C
--*/
#define CMOS_DEV_SIV_C
#include "cmos-dev-siv.h"
#include "../wmt-vid.h"
#include <linux/module.h>
#include <linux/delay.h>

unsigned char siv121d_default_regs_init[]={

0x00,0x00,0x03,0x04,0x10,0x85,0x11,0x74,0x00,0x01,0x04,0x00,0x06,0x04,0x10,0x46,
0x11,0x23,0x12,0x21,0x17,0x86,0x18,0x00,0x20,0x00,0x21,0x05,0x22,0x01,0x23,0x69,
0x40,0x0F,0x41,0x90,0x42,0xd2,0x43,0x00,0x00,0x02,0x10,0x80,0x11,0x0d,0x12,0x50,
0x14,0x4c,0x34,0x96,0x40,0x40,0x5f,0x01,0x90,0x80,0x91,0x80,0x00,0x03,0x10,0xd0,
0x11,0xc1,0x13,0x7e,0x14,0x7d,0x15,0xe0,0x16,0x8c,0x17,0xe0,0x18,0x88,0x19,0x8c,
0x1a,0x64,0x1b,0x98,0x1c,0x6c,0x1d,0x94,0x1e,0x6c,0x20,0xe8,0x21,0x30,0x22,0xb8,
0x23,0x10,0x25,0x08,0x26,0x20,0x27,0x08,0x28,0x0f,0x29,0xba,0x2a,0xa0,0x40,0x01,
0x41,0x04,0x42,0x08,0x43,0x10,0x44,0x12,0x45,0x35,0x46,0x86,0x5F,0x00,0x63,0x90,
0x64,0xe0,0x65,0x90,0x66,0xe0,0x00,0x04,0x10,0xff,0x11,0x1d,0x12,0x3d,0x14,0x00,
0x18,0xbe,0x19,0x00,0x1A,0x00,0x1B,0x00,0x1C,0x0f,0x1d,0xFF,0x1E,0x04,0x1F,0x04,
0x20,0x10,0x21,0x00,0x22,0x10,0x23,0x40,0x24,0x00,0x31,0x04,0x32,0x0f,0x33,0x24,
0x34,0x46,0x35,0x62,0x36,0x78,0x37,0x8b,0x38,0x9B,0x39,0xA8,0x3a,0xb6,0x3b,0xcc,
0x3c,0xe0,0x3d,0xf0,0x40,0x06,0x41,0x44,0x42,0x43,0x43,0x20,0x44,0x11,0x45,0x11,
0x46,0x00,0x47,0x00,0x48,0x00,0x49,0x00,0x4a,0x04,0x4b,0x48,0x4c,0xe8,0x4d,0x80,
0x4e,0x00,0x4f,0x00,0x50,0x00,0x60,0x7f,0x61,0x08,0x71,0x3B,0x72,0xCE,0x73,0xF7,
0x74,0x13,0x75,0x25,0x76,0x08,0x77,0xF2,0x78,0xC7,0x79,0x47,0x83,0x38,0x84,0xd1,
0x85,0xf7,0x86,0x12,0x87,0x25,0x88,0x09,0x89,0xed,0x8a,0xbb,0x8b,0x58,0x8c,0x10,
0x90,0x18,0x91,0x28,0x92,0x44,0x9a,0x40,0x9b,0x40,0x9c,0x30,0x9d,0x30,0xa9,0x11,
0xaa,0x11,0xb9,0x30,0xba,0x23,0xc0,0x24,0xc1,0x00,0xc2,0x80,0xc3,0x00,0xc4,0xe0,
0xcb,0x00,0xde,0x80,0xe5,0x15,0xe6,0x02,0xe7,0x04,0xE8,0x00,0xE9,0x00,0xEA,0x00,
0xEB,0x00,0xEC,0x00,0x00,0x01,0x03,0x01,

};

unsigned char siv121d_640_480_regs[]={
0x00,0x01,0x06,0x04,0x00,0x04,0xc0,0x24,0xc1,0x00,0xc2,0x80,0xc3,0x00,0xc4,0xe0,
};

unsigned char siv121d_320_240_regs[]={
0x00,0x01,0x06,0x06,0x00,0x04,0xc0,0x10,0xc1,0x00,0xc2,0x40,0xc3,0x00,0xc4,0xf0,
};

int cmos_siv121d_identify(void)
{
    char data=0x0;
		
    printk("cmos_siv121d_identify()\n");
    wmt_vid_i2c_write( CMOS_SIV121D_I2C_ADDR, 0x00, 0x0);
    data = wmt_vid_i2c_read(CMOS_SIV121D_I2C_ADDR,0x01);
    
    if(data ==0xde){
        printk("find cmos device siv121d\n");
        return 0;
    }else{
        printk("can't find cmos device siv121d\n");
    }

    return -1;
}





int cmos_init_siv121d(cmos_init_arg_t  *init_arg)
{
    unsigned char *array_addr,data;
    unsigned int array_size;
    printk(">> cmos_init_siv121d %d %d \n", init_arg->width, init_arg->height);

    if (init_arg->is_full_init){
        
        array_size=sizeof(siv121d_default_regs_init);
        array_addr=siv121d_default_regs_init;
        write_array_2_i2c(CMOS_SIV121D_I2C_ADDR, array_addr, array_size);
        
    }

    if ((init_arg->width == 640) && ( init_arg->height == 480)){
        printk(" siv121d_640x480_key init \n");
        array_size=sizeof(siv121d_640_480_regs);
        array_addr=siv121d_640_480_regs;
    }else if((init_arg->width == 320) && ( init_arg->height == 240)){
        printk("init siv121d_320x240_key \n");
        array_size=sizeof(siv121d_320_240_regs);
        array_addr=siv121d_320_240_regs;
    }else{
        printk(">[ERR] not support resolution \n");
        return -1;
    }
    
    printk("\n >>write_array_2_i2c() \n");
    write_array_2_i2c(CMOS_SIV121D_I2C_ADDR, array_addr, array_size);
        
		
    wmt_vid_i2c_write( CMOS_SIV121D_I2C_ADDR, 0x00, 0x1);
    data = wmt_vid_i2c_read(CMOS_SIV121D_I2C_ADDR, 0x04);
    printk("cmos_v_flip %d cmos_h_flip %d \n", init_arg->cmos_v_flip, init_arg->cmos_h_flip);
    if (init_arg->cmos_v_flip)//y-flip
        data |= 0x2;
	
    if (init_arg->cmos_h_flip)//x-flip
        data |= 0x1;

    wmt_vid_i2c_write( CMOS_SIV121D_I2C_ADDR, 0x04, data);

    return 0;
}

int cmos_exit_siv121d(void)
{
    return 0;
}