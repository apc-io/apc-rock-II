/*++ 
 * linux/sound/soc/codecs/wmt_fm34.c
 * WonderMedia echo cancellation driver
 *
 * Copyright c 2010  WonderMedia  Technologies, Inc.
 *
 * This program is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, either version 2 of the License, or 
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details. 
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WonderMedia Technologies, Inc.
 * 4F, 533, Chung-Cheng Road, Hsin-Tien, Taipei 231, R.O.C
--*/

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/i2c.h>
#include <linux/version.h>
#include <linux/slab.h>
#include <linux/workqueue.h>

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/types.h>
#include <linux/mm.h>
#include <linux/kdev_t.h>
#include <asm/page.h>
#include <linux/cdev.h>
#include <linux/device.h>

#include <linux/gpio.h>
#include <mach/wmt_iomux.h>

#define FM34_DEVID      0x501a
#define FM34_I2C_BUS_NR 4

#define FM34_CTRL_NAME  "wmt_echo"
static int fm34_ctrl_major = 0;
static struct cdev fm34_ctrl_dev;
static struct class *fm34_ctrl_class;

// FM34 control interface commands
#define FM34_CMD_ECHO        _IOWR('E', 0x01, int)
#define FM34_CMD_BYPASS      _IOWR('E', 0x02, int)
#define FM34_CMD_INCALL_MAIN_MIC     _IOWR('E', 0x04, int)
#define FM34_CMD_INCALL_HEADSET_MIC  _IOWR('E', 0x08, int)
#define FM34_CMD_CAPTURE_MAIN_MIC    _IOWR('E', 0x10, int)
#define FM34_CMD_CAPTURE_HEADSET_MIC _IOWR('E', 0x20, int)

enum FM34_MODE_TYPE {
	FM34_MODE_ECHO,
	FM34_MODE_BYPASS,
	FM34_MODE_MAX,
};

enum FM34_MIC_SOURCE {
	FM34_INCALL_MIC_MAIN,
	FM34_INCALL_MIC_HEADSET,
	FM34_CAPTURE_MIC_MAIN,
	FM34_CAPTURE_MIC_HEADSET,
	FM34_MIC_MAX,
};

extern int wmt_getsyspara(char *varname, unsigned char *varval, int *varlen);

struct fm34_ctrl_gpo {
	int enable;
	int gpio;
	int active;
};

static struct fm34_ctrl_gpo fm34_reset;
static struct fm34_ctrl_gpo fm34_powerdown;
static struct fm34_ctrl_gpo fm34_bypass;

struct fm34 {
	int (*read_dev)(struct fm34 *fm34, 
			    const u8 wdata[], int wsize, 
			    u8 rdata[], int rsize);
	int (*write_dev)(struct fm34 *fm34, const u8 wdata[], int wsize);
	void *control_data;
	struct device *dev;
	struct delayed_work delaywork;
};

static struct fm34 *fm34_context;
static enum FM34_MODE_TYPE fm_mode = FM34_MODE_MAX;
static enum FM34_MIC_SOURCE fm_mic = FM34_MIC_MAX;

static const u8 wmt_fm34_incall_main_mic[] = {
	0xFC, 0xF3, 0x3B, 0x22, 0xC0, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x22, 0xC1, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x22, 0xC2, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xC3, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xC6, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC7, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC8, 0x00, 0x2C,
    0xFC, 0xF3, 0x3B, 0x22, 0xD2, 0x12, 0x94,
    0xFC, 0xF3, 0x3B, 0x22, 0xEE, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF2, 0x00, 0x40,
    0xFC, 0xF3, 0x3B, 0x22, 0xF6, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xF8, 0x80, 0x05,
    0xFC, 0xF3, 0x3B, 0x22, 0xF9, 0x20, 0xFF,
    0xFC, 0xF3, 0x3B, 0x22, 0xFA, 0x22, 0x8B,
    0xFC, 0xF3, 0x3B, 0x23, 0x01, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x02, 0x01, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x03, 0x09, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x04, 0x03, 0x1E,
    0xFC, 0xF3, 0x3B, 0x23, 0x05, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x07, 0xF0, 0xF0,
    0xFC, 0xF3, 0x3B, 0x23, 0x08, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0A, 0x1B, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0C, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x48, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x49, 0x06, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6E, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6F, 0x0A, 0x0A,
    0xFC, 0xF3, 0x3B, 0x23, 0x70, 0x0F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x73, 0x22, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x74, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x75, 0x12, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x77, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x7B, 0x00, 0x08,
    0xFC, 0xF3, 0x3B, 0x23, 0x86, 0x48, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x8C, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9C, 0x60, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9D, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9E, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xBD, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCE, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCF, 0x0A, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD0, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD1, 0x02, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD2, 0x05, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xED, 0x05, 0x40,
    0xFC, 0xF3, 0x3B, 0x23, 0xEE, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD5, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x80, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x23, 0x81, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x82, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x83, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x84, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x23, 0x85, 0x00, 0x05,
    0xFC, 0xF3, 0x3B, 0x23, 0x8E, 0x70, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x90, 0xA9, 0x87,
    0xFC, 0xF3, 0x3B, 0x23, 0x91, 0x76, 0x54,
    0xFC, 0xF3, 0x3B, 0x23, 0x93, 0x44, 0x55,
    0xFC, 0xF3, 0x3B, 0x23, 0x94, 0x55, 0x66,
    0xFC, 0xF3, 0x3B, 0x23, 0x95, 0x66, 0x77,
    0xFC, 0xF3, 0x3B, 0x23, 0x96, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x97, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x98, 0x00, 0x20,
    0xFC, 0xF3, 0x3B, 0x23, 0xA5, 0x00, 0x06,
    0xFC, 0xF3, 0x3B, 0x23, 0xA8, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xA9, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAA, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAB, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAC, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAD, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAE, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAF, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB0, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB1, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x09, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB3, 0x00, 0x20,
    0xFC, 0xF3, 0x3B, 0x23, 0xB4, 0x00, 0x18,
    0xFC, 0xF3, 0x3B, 0x23, 0x10, 0x48, 0x90,
    0xFC, 0xF3, 0x3B, 0x23, 0x2F, 0x01, 0x40,
    0xFC, 0xF3, 0x3B, 0x23, 0x32, 0x00, 0x30,
    0xFC, 0xF3, 0x3B, 0x23, 0x33, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x23, 0x37, 0x00, 0x02,
    0xFC, 0xF3, 0x3B, 0x23, 0x39, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x22, 0xFB, 0x00, 0x00
};

static const u8 wmt_fm34_incall_headset_mic[] = {
	0xFC, 0xF3, 0x3B, 0x22, 0xC0, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x22, 0xC1, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x22, 0xC2, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xC3, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xC6, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC7, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC8, 0x00, 0x2C,
    0xFC, 0xF3, 0x3B, 0x22, 0xD2, 0x12, 0x94,
    0xFC, 0xF3, 0x3B, 0x22, 0xEE, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF2, 0x00, 0x40,
    0xFC, 0xF3, 0x3B, 0x22, 0xF6, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xF8, 0x80, 0x05,
    0xFC, 0xF3, 0x3B, 0x22, 0xF9, 0x20, 0xFF,
    0xFC, 0xF3, 0x3B, 0x22, 0xFA, 0x22, 0x8B,
    0xFC, 0xF3, 0x3B, 0x23, 0x01, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x02, 0x01, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x03, 0x09, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x04, 0x03, 0x1E,
    0xFC, 0xF3, 0x3B, 0x23, 0x05, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x07, 0xF0, 0xF0,
    0xFC, 0xF3, 0x3B, 0x23, 0x08, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0A, 0x1A, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0C, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x48, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x49, 0x06, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6E, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6F, 0x0A, 0x0A,
    0xFC, 0xF3, 0x3B, 0x23, 0x70, 0x0F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x73, 0x22, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x74, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x75, 0x12, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x77, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x7B, 0x00, 0x08,
    0xFC, 0xF3, 0x3B, 0x23, 0x86, 0x48, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x8C, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9C, 0x60, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9D, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9E, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xBD, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCE, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCF, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD0, 0x06, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD1, 0x02, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD2, 0x05, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xED, 0x05, 0x40,
    0xFC, 0xF3, 0x3B, 0x23, 0xEE, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD5, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x80, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x23, 0x81, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x82, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x83, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x84, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x23, 0x85, 0x00, 0x05,
    0xFC, 0xF3, 0x3B, 0x23, 0x8E, 0x70, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x90, 0xA9, 0x87,
    0xFC, 0xF3, 0x3B, 0x23, 0x91, 0x76, 0x54,
    0xFC, 0xF3, 0x3B, 0x23, 0x93, 0x44, 0x55,
    0xFC, 0xF3, 0x3B, 0x23, 0x94, 0x55, 0x66,
    0xFC, 0xF3, 0x3B, 0x23, 0x95, 0x66, 0x77,
    0xFC, 0xF3, 0x3B, 0x23, 0x96, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x97, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x98, 0x00, 0x20,
    0xFC, 0xF3, 0x3B, 0x23, 0xA5, 0x00, 0x06,
    0xFC, 0xF3, 0x3B, 0x23, 0xA8, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xA9, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAA, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAB, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAC, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAD, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAE, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAF, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB0, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB1, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x09, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB3, 0x00, 0x06,
    0xFC, 0xF3, 0x3B, 0x23, 0xB4, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x10, 0x48, 0x90,
    0xFC, 0xF3, 0x3B, 0x23, 0x2F, 0x01, 0x40,
    0xFC, 0xF3, 0x3B, 0x23, 0x32, 0x00, 0x30,
    0xFC, 0xF3, 0x3B, 0x23, 0x33, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x23, 0x37, 0x00, 0x02,
    0xFC, 0xF3, 0x3B, 0x23, 0x39, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x22, 0xFB, 0x00, 0x00
};

static const u8 wmt_fm34_capture_main_mic[] = {
	0xFC, 0xF3, 0x3B, 0x22, 0x9F, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x22, 0xC6, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC7, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC8, 0x00, 0x2C,
    0xFC, 0xF3, 0x3B, 0x22, 0xEE, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF2, 0x00, 0x40,
    0xFC, 0xF3, 0x3B, 0x22, 0xF6, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xF7, 0x01, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF8, 0x80, 0x02,
    0xFC, 0xF3, 0x3B, 0x22, 0xF9, 0x67, 0xFF,
    0xFC, 0xF3, 0x3B, 0x22, 0xFA, 0x23, 0x8B,
    0xFC, 0xF3, 0x3B, 0x23, 0x01, 0x00, 0x02,
    0xFC, 0xF3, 0x3B, 0x23, 0x02, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x03, 0x29, 0x88,
    0xFC, 0xF3, 0x3B, 0x23, 0x04, 0x20, 0x0E,
    0xFC, 0xF3, 0x3B, 0x23, 0x05, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x07, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x08, 0x0C, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0A, 0x1B, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0C, 0x02, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x48, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6E, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x23, 0x6F, 0x0B, 0x05,
    0xFC, 0xF3, 0x3B, 0x23, 0x70, 0x0C, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x73, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x74, 0x21, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x75, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x7B, 0x00, 0x08,
    0xFC, 0xF3, 0x3B, 0x23, 0x82, 0x05, 0x80,
    0xFC, 0xF3, 0x3B, 0x23, 0x83, 0x03, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x84, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x23, 0x86, 0x48, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x8C, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x90, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0x91, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0x92, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0x93, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0xBD, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCE, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCF, 0x12, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD0, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD1, 0x07, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD2, 0x05, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD5, 0x70, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xED, 0x0A, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xEE, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x28, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x22, 0xF1, 0xD0, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xFB, 0x00, 0x00
};

static const u8 wmt_fm34_capture_headset_mic[] = {
	0xFC, 0xF3, 0x3B, 0x22, 0x9F, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x22, 0xC6, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC7, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC8, 0x00, 0x2C,
    0xFC, 0xF3, 0x3B, 0x22, 0xEE, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF2, 0x00, 0x40,
    0xFC, 0xF3, 0x3B, 0x22, 0xF6, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xF7, 0x01, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF8, 0x80, 0x02,
    0xFC, 0xF3, 0x3B, 0x22, 0xF9, 0x67, 0xFF,
    0xFC, 0xF3, 0x3B, 0x22, 0xFA, 0x23, 0x8B,
    0xFC, 0xF3, 0x3B, 0x23, 0x01, 0x00, 0x02,
    0xFC, 0xF3, 0x3B, 0x23, 0x02, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x03, 0x29, 0x88,
    0xFC, 0xF3, 0x3B, 0x23, 0x04, 0x20, 0x0E,
    0xFC, 0xF3, 0x3B, 0x23, 0x05, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x07, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x08, 0x0C, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0A, 0x1A, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0C, 0x02, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x48, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6E, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x23, 0x6F, 0x0B, 0x05,
    0xFC, 0xF3, 0x3B, 0x23, 0x70, 0x0C, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x73, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x74, 0x21, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x75, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x7B, 0x00, 0x08,
    0xFC, 0xF3, 0x3B, 0x23, 0x82, 0x05, 0x80,
    0xFC, 0xF3, 0x3B, 0x23, 0x83, 0x03, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x84, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x23, 0x86, 0x48, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x8C, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x90, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0x91, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0x92, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0x93, 0x44, 0x44,
    0xFC, 0xF3, 0x3B, 0x23, 0xBD, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCE, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCF, 0x12, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD0, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD1, 0x07, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD2, 0x05, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD5, 0x70, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xED, 0x0A, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xEE, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x28, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x22, 0xF1, 0xD0, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xFB, 0x00, 0x00
};

static int fm34_check_functionality(struct fm34 *fm34)
{
	u8 rdata1, rdata2;
	int devid = 0;
	const u8 wdata1[] = {
		0xFC, 0xF3, 0x27, 0x37, 0xFF
	};
	const u8 wdata2[] = {
		0xFC, 0xF3, 0x60, 0x25
	};
	const u8 wdata3[] = {
		0xFC, 0xF3, 0x60, 0x26
	};
		
	if (fm34->write_dev(fm34, wdata1, sizeof(wdata1)))
		return 0;

	if (fm34->read_dev(fm34, wdata2, sizeof(wdata2), &rdata1, 1) ||
		fm34->read_dev(fm34, wdata3, sizeof(wdata3), &rdata2, 1))
		return 0;

	devid = (rdata2 << 8) | rdata1;
	printk("-->fm34_check_functionality: %x\n", devid);
	if (devid == FM34_DEVID)
		return 1;
	
	return 0;
}

static int fm34_i2c_write(struct fm34 *fm34, const u8 wdata[], int wsize)
{
	int ret;
	struct i2c_client *i2c = fm34->control_data;
	struct i2c_msg xfer[1];

	/*
	 * [MSG1]: fill the register address data
	 * fill the data Tx buffer
	 */
	xfer[0].addr = i2c->addr;
	xfer[0].flags = 0 ;
	xfer[0].flags &= ~(I2C_M_RD);
	xfer[0].buf = (__u8 *)wdata;
	xfer[0].len = wsize;

	/* i2c_transfer returns number of messages transferred */
	ret = i2c_transfer(i2c->adapter, xfer, ARRAY_SIZE(xfer));
	if (ret != ARRAY_SIZE(xfer)) {
		pr_err("fm34_i2c_write err[%d]\n", ret);
		if (ret < 0)
			return ret;
		else
			return -EIO;
	} else
		return 0;
}

static int fm34_i2c_read(struct fm34 *fm34, 
			    const u8 wdata[], int wsize, 
			    u8 rdata[], int rsize)
{
	int ret;
	struct i2c_client *i2c = fm34->control_data;
	struct i2c_msg xfer[2];

	/* [MSG1] fill the register address data */
	xfer[0].addr = i2c->addr;
	xfer[0].flags = 2;	/* Read the register val */
	xfer[0].buf = (__u8 *)wdata;
	xfer[0].len = wsize;
	
	/* [MSG2] fill the data rx buffer */
	xfer[1].addr = i2c->addr;
	xfer[1].flags = I2C_M_RD;	/* Read the register val */
	xfer[1].len = rsize;	/* only n bytes */
	xfer[1].buf = rdata;

	/* i2c_transfer returns number of messages transferred */
	ret = i2c_transfer(i2c->adapter, xfer, ARRAY_SIZE(xfer));
	if (ret != ARRAY_SIZE(xfer)) {
		pr_err("vt1603_i2c_read err[%d]\n", ret);
		if (ret < 0)
			return ret;
		else
			return -EIO;
	} else {
		return 0;
	}
}

static void fm34_timing_init(void)
{
	// pwdn high to power up fm34 module
	if (fm34_powerdown.enable) {
		gpio_set_value_cansleep(fm34_powerdown.gpio, !!fm34_powerdown.active);
		msleep(100);
	}

	// reset fm34 module
	if (fm34_reset.enable) {
		gpio_set_value_cansleep(fm34_reset.gpio, !!fm34_reset.active);
		msleep(10);
		gpio_set_value_cansleep(fm34_reset.gpio, !fm34_reset.active);
		msleep(10);
		gpio_set_value_cansleep(fm34_reset.gpio, !!fm34_reset.active);
		msleep(100);
	}

	// disable fm34 bypass
	if (fm34_bypass.enable) {
		gpio_set_value_cansleep(fm34_bypass.gpio, !!fm34_bypass.active);
	}
}

static void fm34_do_work(struct work_struct *work)
{
	struct fm34 *fm34 = container_of(work, struct fm34, delaywork.work);

	fm34_timing_init();

	if (fm34_check_functionality(fm34) == 0) {
		pr_err("fm34_check_functionality: wrong device id\n");
	}
	
	fm34->write_dev(fm34, wmt_fm34_incall_main_mic, sizeof(wmt_fm34_incall_main_mic));
	//fm_mode = FM34_MODE_ECHO;
	fm_mic = FM34_INCALL_MIC_MAIN;
}

static int __devinit fm34_i2c_probe(struct i2c_client *i2c,
			    const struct i2c_device_id *id)
{
	struct fm34 *fm34;
	int ret;

	if (i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C) == 0) {
		pr_err("i2c_check_functionality: can't talk I2C?\n");
		return -EIO;
	}

	fm34 = kzalloc(sizeof(struct fm34), GFP_KERNEL);
	if (fm34 == NULL)
		return -ENOMEM;

	fm34->dev = &i2c->dev;
	fm34->control_data = i2c;
	fm34->read_dev = fm34_i2c_read;
	fm34->write_dev = fm34_i2c_write;

	i2c_set_clientdata(i2c, fm34);
	dev_set_drvdata(fm34->dev, fm34);

	INIT_DELAYED_WORK(&fm34->delaywork, fm34_do_work);

	if (fm34_powerdown.enable && gpio_is_valid(fm34_powerdown.gpio)) {
		ret = gpio_request(fm34_powerdown.gpio, "FM34-powerdown");
		if (ret < 0){
			dev_warn(fm34->dev, "cann't register fm34_powerdown.gpio-%d\n", fm34_powerdown.gpio);
			fm34_powerdown.enable = 0;
		}
		else
			gpio_direction_output(fm34_powerdown.gpio, 0);
	}
	
	if (fm34_reset.enable && gpio_is_valid(fm34_reset.gpio)) {
		ret = gpio_request(fm34_reset.gpio, "FM34-reset");
		if (ret < 0) {
			dev_warn(fm34->dev, "cann't register fm34_reset.gpio-%d\n", fm34_reset.gpio);
			fm34_reset.enable = 0;
		}
		else
			gpio_direction_output(fm34_reset.gpio, 0);
	}

	if (fm34_bypass.enable && gpio_is_valid(fm34_bypass.gpio)) {
		ret = gpio_request(fm34_bypass.gpio, "FM34-bypass");
		if (ret < 0) {
			dev_warn(fm34->dev, "cann't register fm34_bypass.gpio-%d\n", fm34_bypass.gpio);
			fm34_bypass.enable = 0;
		}
		else
			gpio_direction_output(fm34_bypass.gpio, 0);
	}

	fm34_timing_init();

	if (fm34_check_functionality(fm34) == 0) {
		pr_err("fm34_check_functionality: wrong device id\n");
		return -EIO;
	}

	fm34_context = fm34;

	/* write the firmware to device */
	fm34->write_dev(fm34, wmt_fm34_incall_main_mic, sizeof(wmt_fm34_incall_main_mic));
	fm_mode = FM34_MODE_ECHO; // default is echo mode
	fm_mic = FM34_INCALL_MIC_MAIN;
	return 0;
}

static int __devexit fm34_i2c_remove(struct i2c_client *i2c)
{
	struct fm34 *fm34 = i2c_get_clientdata(i2c);

	if (fm34_powerdown.enable) {
		gpio_free(fm34_powerdown.gpio);
	}
	if (fm34_reset.enable) {
		gpio_free(fm34_reset.gpio);
	}
	if (fm34_bypass.enable) {
		gpio_free(fm34_bypass.gpio);
	}
	
	kfree(fm34);
	return 0;
}

static int fm34_suspend(struct i2c_client *i2c, pm_message_t mesg)
{
	struct fm34 *fm34 = i2c_get_clientdata(i2c);
	cancel_delayed_work_sync(&fm34->delaywork);	
	return 0;
}
static int fm34_resume(struct i2c_client *i2c)
{
	struct fm34 *fm34 = i2c_get_clientdata(i2c);
	schedule_delayed_work(&fm34->delaywork, msecs_to_jiffies(2000));
	return 0;
}

static const struct i2c_device_id fm34_i2c_id[] = {
	{ "wmt-fm34", 0 },
	{ },
};
MODULE_DEVICE_TABLE(i2c, fm34_i2c_id);

static struct i2c_driver fm34_i2c_driver = {
	.driver = {
		.name = "wmt-fm34",
		.owner = THIS_MODULE,
	},
	.probe =    fm34_i2c_probe,
	.remove =   __devexit_p(fm34_i2c_remove),
	.suspend = fm34_suspend,
	.resume = fm34_resume,
	.id_table = fm34_i2c_id,
};

static struct i2c_board_info fm34_i2c_board_info = {
	I2C_BOARD_INFO("wmt-fm34", 0xc0>>1),
};

static int fm34_ctrl_open (struct inode *inode, struct file *filp)
{
	printk("%s %d\n", __func__, __LINE__);
	return 0;
}

static int fm34_ctrl_release(struct inode *inode, struct file *filp)
{
	printk("%s %d\n", __func__, __LINE__);
	return 0;
}

static ssize_t fm34_ctrl_read(struct file *filp, char __user *buf, size_t size, loff_t *offp)
{
	printk("%s %d\n", __func__, __LINE__);
	return size;
}

static long fm34_ctrl_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	const u8 echo[]   = { 0xFC, 0xF3, 0x3B, 0x23, 0x00, 0x00, 0x00 };
	const u8 bypass[] = { 0xFC, 0xF3, 0x3B, 0x23, 0x00, 0x00, 0x01 };
	//const u8 main_mic[] = { 0xFC, 0xF3, 0x3B, 0x23, 0x0a, 0x1a, 0x00 };
	//const u8 headset_mic[]  = { 0xFC, 0xF3, 0x3B, 0x23, 0x0a, 0x1b, 0x00 };
	
	switch (cmd) {
	case FM34_CMD_ECHO:
		if (fm_mode != FM34_MODE_ECHO) {
			printk("FM34 cmd: echo\n");
			if (fm34_context->write_dev(fm34_context, echo, sizeof(echo)))
				return -EIO;
			fm_mode = FM34_MODE_ECHO;
		}
		break;
		
	case FM34_CMD_BYPASS:	
		if (fm_mode != FM34_MODE_BYPASS) {
			printk("FM34 cmd: bypass\n");
			if (fm34_context->write_dev(fm34_context, bypass, sizeof(bypass)))
				return -EIO;
			fm_mode = FM34_MODE_BYPASS;
		}
		break;
		
	case FM34_CMD_INCALL_MAIN_MIC:
		if (fm_mic != FM34_INCALL_MIC_MAIN) {
			printk("FM34 cmd: incall main-mic\n");
			if (fm34_reset.enable) {
				gpio_set_value_cansleep(fm34_reset.gpio, !fm34_reset.active);
				msleep(20);
				gpio_set_value_cansleep(fm34_reset.gpio, !!fm34_reset.active);
				msleep(20);
			}
			if (fm34_context->write_dev(fm34_context, wmt_fm34_incall_main_mic, sizeof(wmt_fm34_incall_main_mic)))
				return -EIO;
			fm_mic = FM34_INCALL_MIC_MAIN;
		}
		break;
		
	case FM34_CMD_INCALL_HEADSET_MIC:
		if (fm_mic != FM34_INCALL_MIC_HEADSET) {
			printk("FM34 cmd: incall headset-mic\n");
			if (fm34_reset.enable) {
				gpio_set_value_cansleep(fm34_reset.gpio, !fm34_reset.active);
				msleep(20);
				gpio_set_value_cansleep(fm34_reset.gpio, !!fm34_reset.active);
				msleep(20);
			}
			if (fm34_context->write_dev(fm34_context, wmt_fm34_incall_headset_mic, sizeof(wmt_fm34_incall_headset_mic)))
				return -EIO;
			fm_mic = FM34_INCALL_MIC_HEADSET;
		}
		break;

	case FM34_CMD_CAPTURE_MAIN_MIC:
		if (fm_mic != FM34_CMD_CAPTURE_MAIN_MIC) {
			printk("FM34 cmd: capture main-mic\n");
			if (fm34_reset.enable) {
				gpio_set_value_cansleep(fm34_reset.gpio, !fm34_reset.active);
				msleep(20);
				gpio_set_value_cansleep(fm34_reset.gpio, !!fm34_reset.active);
				msleep(20);
			}
			if (fm34_context->write_dev(fm34_context, wmt_fm34_capture_main_mic, sizeof(wmt_fm34_capture_main_mic)))
				return -EIO;
			fm_mic = FM34_CMD_CAPTURE_MAIN_MIC;
		}
		break;
		
	case FM34_CMD_CAPTURE_HEADSET_MIC:
		if (fm_mic != FM34_CMD_CAPTURE_HEADSET_MIC) {
			printk("FM34 cmd: capture headset-mic\n");
			if (fm34_reset.enable) {
				gpio_set_value_cansleep(fm34_reset.gpio, !fm34_reset.active);
				msleep(20);
				gpio_set_value_cansleep(fm34_reset.gpio, !!fm34_reset.active);
				msleep(20);
			}
			if (fm34_context->write_dev(fm34_context, wmt_fm34_capture_headset_mic, sizeof(wmt_fm34_capture_headset_mic)))
				return -EIO;
			fm_mic = FM34_CMD_CAPTURE_HEADSET_MIC;
		}
		break;
		
	default:
		printk(KERN_ERR "FM34: Not support cmd[%d]\n", cmd);
		break;
	}

	return 0;
}

static struct file_operations fm34_ctrl_ops = {
	.owner   = THIS_MODULE,
	.open    = fm34_ctrl_open,
	.release = fm34_ctrl_release,
	.read    = fm34_ctrl_read,
	.unlocked_ioctl = fm34_ctrl_ioctl,
};

static int fm34_ctrl_setup_cdev(struct cdev *dev, int minor, struct file_operations *fops)
{
	int ret, devno = MKDEV(fm34_ctrl_major, minor);
	cdev_init(dev, fops);
	dev->owner = THIS_MODULE;
	dev->ops = fops;
	ret = cdev_add(dev, devno, 1);
	if (ret)
		printk(KERN_ERR "Error %d adding wmt_echo %d", ret, minor);
	return ret;
}

static int __init fm34_init(void)
{
	int ret = -1;
	int len = 64;
	char buf[64];
	dev_t dev;
	struct i2c_adapter *adapter;
	struct i2c_client *client;
	
	ret = wmt_getsyspara("wmt.echo.cancellation", buf, &len);
	if (ret == 0) {
		sscanf(buf, "fm34:[%d:%d:%d]:[%d:%d:%d]:[%d:%d:%d]",
			&fm34_powerdown.enable, &fm34_powerdown.gpio, &fm34_powerdown.active,
			&fm34_reset.enable, &fm34_reset.gpio, &fm34_reset.active,
			&fm34_bypass.enable, &fm34_bypass.gpio, &fm34_bypass.active);
	}
	else {
		fm34_reset.enable = 0;
		fm34_powerdown.enable = 0;
		fm34_bypass.enable = 0;
	}

	ret = alloc_chrdev_region(&dev, 0, 1, FM34_CTRL_NAME);
	if (ret == 0)
		fm34_ctrl_major = MAJOR(dev);
	else
		printk(KERN_ERR "fm34: alloc_chrdev_region failed!\n");

	ret = fm34_ctrl_setup_cdev(&fm34_ctrl_dev, 0, &fm34_ctrl_ops);
	if (ret == 0) {
		fm34_ctrl_class = class_create(THIS_MODULE, FM34_CTRL_NAME);
		if (IS_ERR(fm34_ctrl_class)) {
			printk("fm34: class_create failed!\n");
		}
		else
			device_create(fm34_ctrl_class, NULL, MKDEV(fm34_ctrl_major, 0), NULL, FM34_CTRL_NAME);
	}

	adapter = i2c_get_adapter(FM34_I2C_BUS_NR);
	client = i2c_new_device(adapter, &fm34_i2c_board_info);
	i2c_put_adapter(adapter);
	
	ret = i2c_add_driver(&fm34_i2c_driver);
	if (ret != 0)
		pr_err("Failed to register FM34 I2C driver: %d\n", ret);
	return ret;
}
module_init(fm34_init);

static void __exit fm34_exit(void)
{	
	cdev_del(&fm34_ctrl_dev);
	device_destroy(fm34_ctrl_class, MKDEV(fm34_ctrl_major, 0));
	class_destroy(fm34_ctrl_class);
	unregister_chrdev_region(MKDEV(fm34_ctrl_major, 0), 1);
	
	i2c_del_driver(&fm34_i2c_driver);
}
module_exit(fm34_exit);

MODULE_DESCRIPTION("WMT [ALSA SoC/echocancellation] driver");
MODULE_AUTHOR("WonderMedia Technologies, Inc.");
MODULE_LICENSE("GPL");
